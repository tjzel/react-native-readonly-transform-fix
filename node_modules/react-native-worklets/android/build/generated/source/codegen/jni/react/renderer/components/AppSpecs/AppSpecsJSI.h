/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


#pragma mark - NativeCxxModuleExampleEnumInt

enum class NativeCxxModuleExampleEnumInt { IA, IB };

template <>
struct Bridging<NativeCxxModuleExampleEnumInt> {
  static NativeCxxModuleExampleEnumInt fromJs(jsi::Runtime &rt, const jsi::Value &rawValue) {
    double value = (double)rawValue.asNumber();
    if (value == 23) {
      return NativeCxxModuleExampleEnumInt::IA;
    } else if (value == 42) {
      return NativeCxxModuleExampleEnumInt::IB;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeCxxModuleExampleEnumInt");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, NativeCxxModuleExampleEnumInt value) {
    if (value == NativeCxxModuleExampleEnumInt::IA) {
      return bridging::toJs(rt, 23);
    } else if (value == NativeCxxModuleExampleEnumInt::IB) {
      return bridging::toJs(rt, 42);
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeCxxModuleExampleEnumInt");
    }
  }
};

#pragma mark - NativeCxxModuleExampleEnumNone

enum class NativeCxxModuleExampleEnumNone { NA, NB };

template <>
struct Bridging<NativeCxxModuleExampleEnumNone> {
  static NativeCxxModuleExampleEnumNone fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "NA") {
      return NativeCxxModuleExampleEnumNone::NA;
    } else if (value == "NB") {
      return NativeCxxModuleExampleEnumNone::NB;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeCxxModuleExampleEnumNone");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeCxxModuleExampleEnumNone value) {
    if (value == NativeCxxModuleExampleEnumNone::NA) {
      return bridging::toJs(rt, "NA");
    } else if (value == NativeCxxModuleExampleEnumNone::NB) {
      return bridging::toJs(rt, "NB");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeCxxModuleExampleEnumNone");
    }
  }
};

#pragma mark - NativeCxxModuleExampleEnumStr

enum class NativeCxxModuleExampleEnumStr { SA, SB };

template <>
struct Bridging<NativeCxxModuleExampleEnumStr> {
  static NativeCxxModuleExampleEnumStr fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "s---a") {
      return NativeCxxModuleExampleEnumStr::SA;
    } else if (value == "s---b") {
      return NativeCxxModuleExampleEnumStr::SB;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeCxxModuleExampleEnumStr");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeCxxModuleExampleEnumStr value) {
    if (value == NativeCxxModuleExampleEnumStr::SA) {
      return bridging::toJs(rt, "s---a");
    } else if (value == NativeCxxModuleExampleEnumStr::SB) {
      return bridging::toJs(rt, "s---b");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeCxxModuleExampleEnumStr");
    }
  }
};
  
#pragma mark - NativeCxxModuleExampleBinaryTreeNode

template <typename P0>
struct NativeCxxModuleExampleBinaryTreeNode {
  std::unique_ptr<NativeCxxModuleExampleBinaryTreeNode<P0>> left;
  P0 value;
  std::unique_ptr<NativeCxxModuleExampleBinaryTreeNode<P0>> right;
  bool operator==(const NativeCxxModuleExampleBinaryTreeNode &other) const {
    return left == other.left && value == other.value && right == other.right;
  }
};

template <typename T>
struct NativeCxxModuleExampleBinaryTreeNodeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      value.hasProperty(rt, "left") ? std::make_unique<T>(bridging::fromJs<T>(rt, value.getProperty(rt, "left"), jsInvoker)) : nullptr,
      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker),
      value.hasProperty(rt, "right") ? std::make_unique<T>(bridging::fromJs<T>(rt, value.getProperty(rt, "right"), jsInvoker)) : nullptr};
    return result;
  }

#ifdef DEBUG
  static jsi::Object leftToJs(jsi::Runtime &rt, decltype(types.left) value) {
    return bridging::toJs(rt, value);
  }

  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object rightToJs(jsi::Runtime &rt, decltype(types.right) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.left) {
        result.setProperty(rt, "left", bridging::toJs(rt, *value.left, jsInvoker));
      }
    result.setProperty(rt, "value", bridging::toJs(rt, value.value, jsInvoker));
    if (value.right) {
        result.setProperty(rt, "right", bridging::toJs(rt, *value.right, jsInvoker));
      }
    return result;
  }
};



#pragma mark - NativeCxxModuleExampleConstantsStruct

template <typename P0, typename P1, typename P2>
struct NativeCxxModuleExampleConstantsStruct {
  P0 const1;
  P1 const2;
  P2 const3;
  bool operator==(const NativeCxxModuleExampleConstantsStruct &other) const {
    return const1 == other.const1 && const2 == other.const2 && const3 == other.const3;
  }
};

template <typename T>
struct NativeCxxModuleExampleConstantsStructBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.const1)>(rt, value.getProperty(rt, "const1"), jsInvoker),
      bridging::fromJs<decltype(types.const2)>(rt, value.getProperty(rt, "const2"), jsInvoker),
      bridging::fromJs<decltype(types.const3)>(rt, value.getProperty(rt, "const3"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool const1ToJs(jsi::Runtime &rt, decltype(types.const1) value) {
    return bridging::toJs(rt, value);
  }

  static double const2ToJs(jsi::Runtime &rt, decltype(types.const2) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String const3ToJs(jsi::Runtime &rt, decltype(types.const3) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "const1", bridging::toJs(rt, value.const1, jsInvoker));
    result.setProperty(rt, "const2", bridging::toJs(rt, value.const2, jsInvoker));
    result.setProperty(rt, "const3", bridging::toJs(rt, value.const3, jsInvoker));
    return result;
  }
};



#pragma mark - NativeCxxModuleExampleCustomDeviceEvent

template <typename P0, typename P1, typename P2>
struct NativeCxxModuleExampleCustomDeviceEvent {
  P0 type;
  P1 level;
  P2 degree;
  bool operator==(const NativeCxxModuleExampleCustomDeviceEvent &other) const {
    return type == other.type && level == other.level && degree == other.degree;
  }
};

template <typename T>
struct NativeCxxModuleExampleCustomDeviceEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.level)>(rt, value.getProperty(rt, "level"), jsInvoker),
      bridging::fromJs<decltype(types.degree)>(rt, value.getProperty(rt, "degree"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }

  static double levelToJs(jsi::Runtime &rt, decltype(types.level) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> degreeToJs(jsi::Runtime &rt, decltype(types.degree) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    result.setProperty(rt, "level", bridging::toJs(rt, value.level, jsInvoker));
    if (value.degree) {
      result.setProperty(rt, "degree", bridging::toJs(rt, value.degree.value(), jsInvoker));
    }
    return result;
  }
};




#pragma mark - NativeCxxModuleExampleGraphNode

template <typename P0>
struct NativeCxxModuleExampleGraphNode {
  P0 label;
  std::optional<std::vector<NativeCxxModuleExampleGraphNode<P0>>> neighbors;
  bool operator==(const NativeCxxModuleExampleGraphNode &other) const {
    return label == other.label && neighbors == other.neighbors;
  }
};

template <typename T>
struct NativeCxxModuleExampleGraphNodeBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.label)>(rt, value.getProperty(rt, "label"), jsInvoker),
      bridging::fromJs<decltype(types.neighbors)>(rt, value.getProperty(rt, "neighbors"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String labelToJs(jsi::Runtime &rt, decltype(types.label) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array neighborsToJs(jsi::Runtime &rt, decltype(types.neighbors) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "label", bridging::toJs(rt, value.label, jsInvoker));
    if (value.neighbors) {
      result.setProperty(rt, "neighbors", bridging::toJs(rt, value.neighbors.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCxxModuleExampleMenuItem

template <typename P0, typename P1, typename P2>
struct NativeCxxModuleExampleMenuItem {
  P0 label;
  P1 onPress;
  P2 shortcut;
  std::optional<std::vector<NativeCxxModuleExampleMenuItem<P0, P1, P2>>> items;
  bool operator==(const NativeCxxModuleExampleMenuItem &other) const {
    return label == other.label && onPress == other.onPress && shortcut == other.shortcut && items == other.items;
  }
};

template <typename T>
struct NativeCxxModuleExampleMenuItemBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.label)>(rt, value.getProperty(rt, "label"), jsInvoker),
      bridging::fromJs<decltype(types.onPress)>(rt, value.getProperty(rt, "onPress"), jsInvoker),
      bridging::fromJs<decltype(types.shortcut)>(rt, value.getProperty(rt, "shortcut"), jsInvoker),
      bridging::fromJs<decltype(types.items)>(rt, value.getProperty(rt, "items"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String labelToJs(jsi::Runtime &rt, decltype(types.label) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Function onPressToJs(jsi::Runtime &rt, decltype(types.onPress) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> shortcutToJs(jsi::Runtime &rt, decltype(types.shortcut) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array itemsToJs(jsi::Runtime &rt, decltype(types.items) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "label", bridging::toJs(rt, value.label, jsInvoker));
    result.setProperty(rt, "onPress", bridging::toJs(rt, value.onPress, jsInvoker));
    if (value.shortcut) {
      result.setProperty(rt, "shortcut", bridging::toJs(rt, value.shortcut.value(), jsInvoker));
    }
    if (value.items) {
      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCxxModuleExampleObjectStruct

template <typename P0, typename P1, typename P2>
struct NativeCxxModuleExampleObjectStruct {
  P0 a;
  P1 b;
  P2 c;
  bool operator==(const NativeCxxModuleExampleObjectStruct &other) const {
    return a == other.a && b == other.b && c == other.c;
  }
};

template <typename T>
struct NativeCxxModuleExampleObjectStructBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.a)>(rt, value.getProperty(rt, "a"), jsInvoker),
      bridging::fromJs<decltype(types.b)>(rt, value.getProperty(rt, "b"), jsInvoker),
      bridging::fromJs<decltype(types.c)>(rt, value.getProperty(rt, "c"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double aToJs(jsi::Runtime &rt, decltype(types.a) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String bToJs(jsi::Runtime &rt, decltype(types.b) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> cToJs(jsi::Runtime &rt, decltype(types.c) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "a", bridging::toJs(rt, value.a, jsInvoker));
    result.setProperty(rt, "b", bridging::toJs(rt, value.b, jsInvoker));
    if (value.c) {
      result.setProperty(rt, "c", bridging::toJs(rt, value.c.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCxxModuleExampleValueStruct

template <typename P0, typename P1, typename P2>
struct NativeCxxModuleExampleValueStruct {
  P0 x;
  P1 y;
  P2 z;
  bool operator==(const NativeCxxModuleExampleValueStruct &other) const {
    return x == other.x && y == other.y && z == other.z;
  }
};

template <typename T>
struct NativeCxxModuleExampleValueStructBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.x)>(rt, value.getProperty(rt, "x"), jsInvoker),
      bridging::fromJs<decltype(types.y)>(rt, value.getProperty(rt, "y"), jsInvoker),
      bridging::fromJs<decltype(types.z)>(rt, value.getProperty(rt, "z"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static double xToJs(jsi::Runtime &rt, decltype(types.x) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String yToJs(jsi::Runtime &rt, decltype(types.y) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object zToJs(jsi::Runtime &rt, decltype(types.z) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "x", bridging::toJs(rt, value.x, jsInvoker));
    result.setProperty(rt, "y", bridging::toJs(rt, value.y, jsInvoker));
    result.setProperty(rt, "z", bridging::toJs(rt, value.z, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeCxxModuleExampleCxxSpecJSI : public TurboModule {
protected:
  NativeCxxModuleExampleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual bool getBool(jsi::Runtime &rt, bool arg) = 0;
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value getCustomEnum(jsi::Runtime &rt, jsi::Value arg) = 0;
  virtual jsi::Object getCustomHostObject(jsi::Runtime &rt) = 0;
  virtual jsi::String consumeCustomHostObject(jsi::Runtime &rt, jsi::Object customHostObject) = 0;
  virtual jsi::Object getBinaryTreeNode(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Object getGraphNode(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Value getNumEnum(jsi::Runtime &rt, jsi::Value arg) = 0;
  virtual jsi::String getStrEnum(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::Object getMap(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual double getNumber(jsi::Runtime &rt, double arg) = 0;
  virtual jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Array getSet(jsi::Runtime &rt, jsi::Array arg) = 0;
  virtual jsi::String getString(jsi::Runtime &rt, jsi::String arg) = 0;
  virtual jsi::String getUnion(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) = 0;
  virtual jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) = 0;
  virtual void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Function setValueCallbackWithSubscription(jsi::Runtime &rt, jsi::Function callback) = 0;
  virtual jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) = 0;
  virtual std::optional<bool> getWithWithOptionalArgs(jsi::Runtime &rt, std::optional<bool> optionalArg) = 0;
  virtual void voidFunc(jsi::Runtime &rt) = 0;
  virtual jsi::Value voidPromise(jsi::Runtime &rt) = 0;
  virtual void setMenu(jsi::Runtime &rt, jsi::Object menuItem) = 0;
  virtual void emitCustomDeviceEvent(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void voidFuncThrows(jsi::Runtime &rt) = 0;
  virtual jsi::Object getObjectThrows(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Value promiseThrows(jsi::Runtime &rt) = 0;
  virtual void voidFuncAssert(jsi::Runtime &rt) = 0;
  virtual jsi::Object getObjectAssert(jsi::Runtime &rt, jsi::Object arg) = 0;
  virtual jsi::Value promiseAssert(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeCxxModuleExampleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "NativeCxxModuleExampleCxx";

protected:
  NativeCxxModuleExampleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCxxModuleExampleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  void emitOnPress() {
    static_cast<AsyncEventEmitter<>&>(*delegate_.eventEmitterMap_["onPress"]).emit();
  }

  template <typename OnClickType> void emitOnClick(OnClickType value) {
    static_assert(bridging::supportsFromJs<OnClickType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onClick"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnChangeType> void emitOnChange(OnChangeType value) {
    static_assert(bridging::supportsFromJs<OnChangeType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onChange"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnSubmitType> void emitOnSubmit(std::vector<OnSubmitType> value) {
    static_assert(bridging::supportsFromJs<std::vector<OnSubmitType>, jsi::Array>, "value cannnot be converted to jsi::Array");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onSubmit"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnEventType> void emitOnEvent(OnEventType value) {
    static_assert(bridging::supportsFromJs<OnEventType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onEvent"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeCxxModuleExampleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCxxModuleExampleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onPress"] = std::make_shared<AsyncEventEmitter<>>();
      eventEmitterMap_["onClick"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onChange"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onSubmit"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onEvent"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    jsi::Array getArray(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getArray) == 2,
          "Expected getArray(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getArray, jsInvoker_, instance_, std::move(arg));
    }
    bool getBool(jsi::Runtime &rt, bool arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBool) == 2,
          "Expected getBool(...) to have 2 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::getBool, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value getCustomEnum(jsi::Runtime &rt, jsi::Value arg) override {
      static_assert(
          bridging::getParameterCount(&T::getCustomEnum) == 2,
          "Expected getCustomEnum(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCustomEnum, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getCustomHostObject(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCustomHostObject) == 1,
          "Expected getCustomHostObject(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getCustomHostObject, jsInvoker_, instance_);
    }
    jsi::String consumeCustomHostObject(jsi::Runtime &rt, jsi::Object customHostObject) override {
      static_assert(
          bridging::getParameterCount(&T::consumeCustomHostObject) == 2,
          "Expected consumeCustomHostObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::consumeCustomHostObject, jsInvoker_, instance_, std::move(customHostObject));
    }
    jsi::Object getBinaryTreeNode(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getBinaryTreeNode) == 2,
          "Expected getBinaryTreeNode(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getBinaryTreeNode, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getGraphNode(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getGraphNode) == 2,
          "Expected getGraphNode(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getGraphNode, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value getNumEnum(jsi::Runtime &rt, jsi::Value arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumEnum) == 2,
          "Expected getNumEnum(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getNumEnum, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getStrEnum(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getStrEnum) == 2,
          "Expected getStrEnum(...) to have 2 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getStrEnum, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getMap(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getMap) == 2,
          "Expected getMap(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getMap, jsInvoker_, instance_, std::move(arg));
    }
    double getNumber(jsi::Runtime &rt, double arg) override {
      static_assert(
          bridging::getParameterCount(&T::getNumber) == 2,
          "Expected getNumber(...) to have 2 parameters");

      return bridging::callFromJs<double>(
          rt, &T::getNumber, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Object getObject(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObject) == 2,
          "Expected getObject(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObject, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Array getSet(jsi::Runtime &rt, jsi::Array arg) override {
      static_assert(
          bridging::getParameterCount(&T::getSet) == 2,
          "Expected getSet(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::getSet, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getString(jsi::Runtime &rt, jsi::String arg) override {
      static_assert(
          bridging::getParameterCount(&T::getString) == 2,
          "Expected getString(...) to have 2 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getString, jsInvoker_, instance_, std::move(arg));
    }
    jsi::String getUnion(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getUnion) == 4,
          "Expected getUnion(...) to have 4 parameters");

      return bridging::callFromJs<jsi::String>(
          rt, &T::getUnion, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    jsi::Object getValue(jsi::Runtime &rt, double x, jsi::String y, jsi::Object z) override {
      static_assert(
          bridging::getParameterCount(&T::getValue) == 4,
          "Expected getValue(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getValue, jsInvoker_, instance_, std::move(x), std::move(y), std::move(z));
    }
    void getValueWithCallback(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithCallback) == 2,
          "Expected getValueWithCallback(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::getValueWithCallback, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Function setValueCallbackWithSubscription(jsi::Runtime &rt, jsi::Function callback) override {
      static_assert(
          bridging::getParameterCount(&T::setValueCallbackWithSubscription) == 2,
          "Expected setValueCallbackWithSubscription(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Function>(
          rt, &T::setValueCallbackWithSubscription, jsInvoker_, instance_, std::move(callback));
    }
    jsi::Value getValueWithPromise(jsi::Runtime &rt, bool error) override {
      static_assert(
          bridging::getParameterCount(&T::getValueWithPromise) == 2,
          "Expected getValueWithPromise(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getValueWithPromise, jsInvoker_, instance_, std::move(error));
    }
    std::optional<bool> getWithWithOptionalArgs(jsi::Runtime &rt, std::optional<bool> optionalArg) override {
      static_assert(
          bridging::getParameterCount(&T::getWithWithOptionalArgs) == 2,
          "Expected getWithWithOptionalArgs(...) to have 2 parameters");

      return bridging::callFromJs<std::optional<bool>>(
          rt, &T::getWithWithOptionalArgs, jsInvoker_, instance_, std::move(optionalArg));
    }
    void voidFunc(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFunc) == 1,
          "Expected voidFunc(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFunc, jsInvoker_, instance_);
    }
    jsi::Value voidPromise(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidPromise) == 1,
          "Expected voidPromise(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::voidPromise, jsInvoker_, instance_);
    }
    void setMenu(jsi::Runtime &rt, jsi::Object menuItem) override {
      static_assert(
          bridging::getParameterCount(&T::setMenu) == 2,
          "Expected setMenu(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMenu, jsInvoker_, instance_, std::move(menuItem));
    }
    void emitCustomDeviceEvent(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::emitCustomDeviceEvent) == 2,
          "Expected emitCustomDeviceEvent(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::emitCustomDeviceEvent, jsInvoker_, instance_, std::move(eventName));
    }
    void voidFuncThrows(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFuncThrows) == 1,
          "Expected voidFuncThrows(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFuncThrows, jsInvoker_, instance_);
    }
    jsi::Object getObjectThrows(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectThrows) == 2,
          "Expected getObjectThrows(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectThrows, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value promiseThrows(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::promiseThrows) == 1,
          "Expected promiseThrows(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::promiseThrows, jsInvoker_, instance_);
    }
    void voidFuncAssert(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::voidFuncAssert) == 1,
          "Expected voidFuncAssert(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::voidFuncAssert, jsInvoker_, instance_);
    }
    jsi::Object getObjectAssert(jsi::Runtime &rt, jsi::Object arg) override {
      static_assert(
          bridging::getParameterCount(&T::getObjectAssert) == 2,
          "Expected getObjectAssert(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getObjectAssert, jsInvoker_, instance_, std::move(arg));
    }
    jsi::Value promiseAssert(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::promiseAssert) == 1,
          "Expected promiseAssert(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::promiseAssert, jsInvoker_, instance_);
    }

  private:
    friend class NativeCxxModuleExampleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeScreenshotManagerCxxSpecJSI : public TurboModule {
protected:
  NativeScreenshotManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
  virtual jsi::Value takeScreenshot(jsi::Runtime &rt, jsi::String id, jsi::Object options) = 0;

};

template <typename T>
class JSI_EXPORT NativeScreenshotManagerCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "ScreenshotManager";

protected:
  NativeScreenshotManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeScreenshotManagerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeScreenshotManagerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeScreenshotManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Object getConstants(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConstants) == 1,
          "Expected getConstants(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConstants, jsInvoker_, instance_);
    }
    jsi::Value takeScreenshot(jsi::Runtime &rt, jsi::String id, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::takeScreenshot) == 3,
          "Expected takeScreenshot(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::takeScreenshot, jsInvoker_, instance_, std::move(id), std::move(options));
    }

  private:
    friend class NativeScreenshotManagerCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
